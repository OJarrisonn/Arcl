program = {  }

// Identifiers

dontcare = @{"_"}
variable_identifier = @{"_"? ~ 'a'..'z' ~ ('a'..'z' | '0'..'9' | "_")* }
constant_identifier = @{"_"? ~ 'A'..'Z' ~ ('A'..'Z' | "_")*}
type_identifier = @{ 'A'..'Z' ~ ('a'..'z' | 'A..Z' | '0'..'9' | "_")* }
tag_identifier = @{'a'..'z' ~ ('a'..'z' | "-")*}

// Literals

number  =  { integer | float }
index   = @{ "0" | ASCII_NONZERO_DIGIT ~ (ASCII_DIGIT)* }
integer =  { unsigned | decimal | binary | hexadecimal }
// FIXME: Floats não são reconhecidos
float       = @{ ASCII_DIGIT* ~ "." ~ ASCII_DIGIT+ | ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT* }
unsigned    = @{ ASCII_DIGIT ~ (!"." ~ ASCII_DIGIT)* }
decimal     = @{ "-"? ~ ASCII_DIGIT ~ (!"." ~ ASCII_DIGIT)* }
binary      = @{ (ASCII_BIN_DIGIT)+ ~ "b" }
hexadecimal = @{ "0x" ~ (ASCII_HEX_DIGIT)+ }

string         =  { string_literal | template_string }
string_literal = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

template_string     = @{ "`" ~ (!"`" ~ (template_expression | ANY))* ~ "`" }
template_expression = ${ "${" ~ (!"}" ~ expr)* ~ "}" }

char = @{ "'" ~ (!"'" ~ ANY) ~ "'" }
bool = @{ "true " | "false" | "on" | "off" | "yes" | "no" }
null =  { "null" }

// Operators

plus    = { "+" }
minus   = { "-" }
times   = { "*" }
divide  = { "/" }
power   = { "^" }
modulus = { "%" }

and     = { "&&" }
or      = { "||" }
not     = { "!" }

reference = { read_ref | write_ref | deref}
read_ref = {"&"}
write_ref = {"@"}
deref = {"*"}

pipe_forward = { "|>" }

binary_ops = { plus | minus | times | divide }
unary_ops = { minus | not | reference }

// Expressions

expr = {
    (type ~ cast)?~ parcel
}

parcel = {
    parcel2 ~ expr?
}

parcel2 = {
    clause ~ (pipe_forward ~ clause)*
}

clause = {
    subclause ~ (or ~ subclause)*
}

subclause = {
    segment ~ (and ~ segment)*
}

segment = {
    term ~ ((plus | minus) ~ term)*
}

term = {
    factor ~ ((times | divide | modulus) ~ factor)*
}

factor = {
    unary_ops* ~ thing
    | thing ~ (power ~ thing)
}

thing = {
    (
        number
        | string
        | char
        | bool
        | compound_expr
        | function_expr
        | function_call
        | variable_identifier
        | constant_identifier
        | code
        | if_expr
        //| match_expr
    ) ~ chain?
}

compound_expr       = { "(" ~ (expr ~ ",")* ~ expr ~ ")" | "(" ~ ")" | null }

code = {
    "{" ~ ((expr | statement) ~ ";")* ~ expr ~ "}"
}

function_expr       = {
    function_type ~ expr
}

chain = {
    (compound_accesser | collection_accesser | method_accesser)*
}

compound_accesser = @{ "." ~ (unsigned | variable_identifier) }
collection_accesser = { "[" ~ expr ~ "]" }
method_accesser = @{ ":" ~ variable_identifier }

if_expr = {
    "if" ~ expr ~ "=>" ~ expr ~ ("|" ~ expr ~ "=>" ~ expr)* ~ ("else" ~ expr)?
}


// Types

type_arguments = { "<" ~  type_arguments_types? ~ (";" ~ type_arguments_sizes?)  ~ ">" }
type_arguments_types = { (type ~ ",")* ~ type }
type_arguments_sizes = { (unsigned ~ ",")* ~ unsigned }

type = {
    type_identifier ~ type_arguments?
    | compound_type
    | named_compound_type
    | object_type
    | primitive_types
    | function_type
}

compound_type       = { "(" ~ (type ~ ",")* ~ type ~ ")" | "(" ~ ")" | void }
named_compound_type = { "(" ~ (type ~ variable_identifier ~ ",")* ~ type ~ variable_identifier ~ ")" | "(" ~ ")" | void }
object_type         = { "{" ~ (("read" | "write")? ~ type ~ variable_identifier ~ ",")* ~ ("read" | "write")? ~ type ~ variable_identifier ~ "}" }

void      = { "Void" }
primitive_types = { "Int" | "Uint" | "Float" | "Char" | "Bool" }

function_type = { "func" ~ named_compound_type ~ ("->" type)? }

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT    = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | "//" ~ (!NEWLINE ~ ANY)* }